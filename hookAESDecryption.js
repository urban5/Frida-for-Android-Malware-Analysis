// This script hooks native function EVP_DecryptInit_ex by first hooking the wrapping Java method to ensure the corresponding native library is loaded.
// Script outputs AES decryption (or encryption) key and initialization vector (IV) if hooking is successful.

// SHA256 of the sample, following script was used on: 2c05efa757744cb01346fe6b39e9ef8ea2582d27481a441eb885c5c4dcd2b65b
// Detailed unpacking of the sample available in another article written by Cryptax: https://cryptax.medium.com/inside-kangapack-the-kangaroo-packer-with-native-decryption-3e7e054679c4

Java.perform(function () {
    // Configuration
    var targetClass = 'com.hwgapkspv.gouhwkh.Molfwernpozxswfsg';
    var targetMethod = 'abcdesCrypt';
    var libraryName = 'libapksadfsalkwes.so';
    var nativeMethodSignature = '[B';

    // Helper function to check if the library is loaded
    function isLibraryLoaded(libName) {
        var modules = Process.enumerateModules();
        for (var i = 0; i < modules.length; i++) {
            if (modules[i].name === libName) {
                console.log(`[INFO] Library ${libName} is loaded.`);
                return true;
            }
        }
        console.log(`[INFO] Library ${libName} is not loaded.`);
        return false;
    }

    // Hook the Java method
    var targetClassInstance = Java.use(targetClass);
    targetClassInstance[targetMethod].overload(nativeMethodSignature).implementation = function (arg0) {
        console.log(`[INFO] Hooked method ${targetClass}.${targetMethod}`);

        // Check if the library is loaded before the method call
        console.log('[INFO] Checking library before method call:');
        isLibraryLoaded(libraryName);

        // Function to enumerate imports and attach to EVP_DecryptInit_ex
        function enumerateAndAttach() {
            var decryptAddress = null;
            var imports = Module.enumerateImportsSync(libraryName);

            for (var i = 0; i < imports.length; i++) {
                if (imports[i].name === "EVP_DecryptInit_ex") {
                    decryptAddress = imports[i].address;
                    console.log("Found import EVP_DecryptInit_ex at address: " + decryptAddress);
                    break;
                }
            }

            if (decryptAddress) {
                console.log("Attaching to EVP_DecryptInit_ex at address: " + decryptAddress);
                Interceptor.attach(decryptAddress, {
                    onEnter: function (args) {
                        var keyArgument = Memory.readByteArray(ptr(args[3]), 32);
                        var keyHexDump = hexdump(keyArgument, { offset: 0, length: 32, header: true, ansi: true });

                        var keyMessage = "[*] AES Key " + 3 + " " + args[3];
                        console.log(keyMessage);
                        console.log(keyHexDump);

                        var ivArgument = Memory.readByteArray(ptr(args[4]), 16);
                        var ivHexDump = hexdump(ivArgument, { offset: 0, length: 16, header: true, ansi: true });

                        var ivMessage = "[*] AES IV " + 4 + " " + args[4];
                        console.log(ivMessage);
                        console.log(ivHexDump);
                    }
                });
            } else {
                console.log("EVP_DecryptInit_ex not found in imports.");
            }
        }

        // Call the enumeration and attachment function before the method execution
        enumerateAndAttach();

        // Call the original method and capture the return value
        var result = this[targetMethod](arg0);

        // Check if the library is loaded after the method call
        console.log('[INFO] Checking library after method call:');
        isLibraryLoaded(libraryName);

        return result;
    };
});
